---
version: '2.0'

examples.mistral-ask:
    description: A workflow for demonstrating st2.ask functionality
    type: direct

    task-defaults:
        on-error:
            - rejected

    tasks:

        initial_task:
            action: core.local
            input:
                cmd: echo "Beginning approval example workflow"
            on-complete:
                - basic_approval


        # We hit our first approval task. The first time this action runs, the execution context will be empty, so
        # naturally, this data will fail to validate, so the action will return an `awaits` status, and this workflow
        # will be paused. It will remain in this state until someone passes additional data into the executions API.
        # When this happens, the action will re-run, and re-attempt to validate the data in the context. If this data
        # validates, the action will return a success status and will continue with the workflow.
        #
        # If it does not validate, it will return to `awaits` status.
        #
        # Note that the optional "schema" parameter is supplied down in the "ask_for_2fa_token" task, but is omitted here.
        # By default, `st2.ask` will use the default JSON schema (with a bit of built-in logic) that validates a
        # simple approve/reject response stored in the execution context.
        # When this happens, the `st2.ask` will have a bit of conditional logic to detect the approve/reject status
        # and return a success or failed state.
        #
        # So, if someone approves this, such as via an `st2 approve` command, it will continue to task2
        basic_approval:
            action: st2.ask
            on-success:
                - task2

        task2:
            action: core.local
            input:
                cmd: echo "Got to task1"    
            on-complete:
                - ask_for_2fa_token

        # Now, we arrive at our second approval example. We know that one of the upcoming tasks "send_request_with_2fa"
        # requires a password AND a second factor for authentication. We can provide the password here (or in st2kv of course)
        # but for the second factor, we need to ask someone to intervene.
        #
        # In this instance of `st2.ask`, the same initial treatment applies. The execution context is empty,
        # so naturally, it will fail to validate, and the action will return `awaits` status.
        #
        # Note that we're providing our own JSON schema to the `schema` parameter here. `st2.ask` will
        # use this to validate data stored in the execution context instead of the default schema that
        # validates a simple approve/reject response from the user.
        # When we do this, the action doesn't have a way of knowing what a "rejected" approval means,
        # so this will block in `awaits` status until someone sends data into the context that will validate
        # the schema.
        # In this event, the user may want to look into writing their own action that has more detailed checks of
        # the data once validated, if they need this.
        ask_for_2fa_token:
            action: st2.ask
            input:
                schema:
                    title: approval_data
                    type: object
                    properties:
                        second_factor:
                           type: string
                    required: ["second_factor"]
            publish:
                second_factor: <% task(ask_for_2fa_token).result.second_factor %>
            on-success:
                - send_request_with_2fa

        send_request_with_2fa:
            action: testpack.request_with_2fa
            input:
                username: foo
                password: bar
                token: <% $.second_factor %>

        rejected:
            action: core.local
            input:
                cmd: echo "Workflow approval was rejected, or some other failure occurred."
